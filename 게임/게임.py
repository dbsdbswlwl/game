# -*- coding: utf-8 -*-
"""202310725 이윤지 게임

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MWSne1fhIhk6VxcnRaoHP3iupbiQqdvg
"""

import random as rd

class Monstergame:
  def __init__(self):
    self.player_health = 50
    self.monster_health = 50
    self.attempts = 5

  def random_number(self):
      return rd.randint(1,3)

  def user_input(self):
    while True:
      try:
        user_number = int(input('1부터 3 사이의 숫자를 입력하시오.:'))

        if user_number >=1 and user_number <=3 :
          return user_number
        else :
          print('\n알맞은 숫자를 입력하시오.\n')
      except ValueError:
        print('\n알맞은 숫자를 입력하시오.\n')

  def round(self, user_number):
    if user_number == self.random_number():
      print('\n정확합니다! monster의 체력을 10 깎습니다.\n')
      self.monster_health -= 10
      self.attempts += 2
      self.player_health += 10

    else:
      print('\n틀렸습니다. player의 체력을 10 깎습니다.\n')
      self.player_health -= 10
    self.attempts -= 1
    print('monster : {}, 내 체력: {}, 남은 시도 횟수: {}\n'.format(self.monster_health, self.player_health, self.attempts))


  def game(self):
    while self.attempts >= 0:
      if self.monster_health == 0:
        print('\n몬스터를 물리쳤습니다! 축하드립니다!')
        break


      if self.player_health == 0:
        print('\n플레이어의 체력이 0이 되어 게임을 종료합니다.')
        break

      if self.attempts == 0 :
        print('\n시도 횟수가 소진되어 게임을 종료합니다.')
      user_number = self.user_input()
      self.round(user_number)

if __name__ == "__main__":
  x = Monstergame()
  x.game()

import random

HANGMAN = [
    '________',
    '|       |',
    '|       O',
    '|       |',
    '|      /|\ ',
    '|       |',
    '|      / \ '
]

WORDS = [
    'casa', 'car', 'mono', 'elevator', 'python', 'java',
    'pleasure', 'young', 'festival', 'sing', 'class'
]

class Hangman():
    """
    The hangman game class
    """

    def __init__(self, word_to_guess):
        self.failed_attempts = 0
        self.word_to_guess = word_to_guess
        self.game_progress = list('_' * len(self.word_to_guess))

    def find_indexes(self, letter):
        """
        Find indexes of the guessed letter in the word.
        letter: string, the letter to find in the word.
        """
        return [i for i, char in enumerate(self.word_to_guess) if char == letter]

    def is_invalid_letter(self, input_):
        """
        Check if the input is a valid letter.
        input_: string, the input to validate.
        Returns True if the input is invalid, otherwise False.
        """
        return (len(input_) != 1 or not input_.isalpha()) or (input_.isdigit())

    def print_game_status(self):
        """
        Print the current game status, including the hangman figure and the word progress.
        """
        print('\n'.join(HANGMAN[:self.failed_attempts]))
        print(' '.join(self.game_progress))

    def update_progress(self, letter, indexes):
        """
        Update the game progress with the correct letter at the specified indexes.
        letter: string, the letter to update in the game progress.
        indexes: list, the indexes where the letter appears in the word.
        """
        for index in indexes:
            self.game_progress[index] = letter

    def get_user_input(self):
        """
        Get user input for guessing a letter.
        Returns the user input.
        """
        return input("Please type a letter: ").lower()

    def play(self):
        """
        Play the hangman game.
        """
        while True:
            self.print_game_status()
            user_input = self.get_user_input()

            # Validate the user input
            if self.is_invalid_letter(user_input):
                print("Invalid input. Please enter a valid letter.")
                continue

            # Check if the letter is not already guessed
            if user_input in self.game_progress:
                print("You've already guessed that letter. Try again.")
                continue

            # Check if the guessed letter is in the word
            if user_input in self.word_to_guess:
                indexes = self.find_indexes(user_input)
                self.update_progress(user_input, indexes)

                # If there are no more letters to find
                if '_' not in self.game_progress:
                    print('\n------Yay! You win!')
                    print('The word is: {0}'.format(self.word_to_guess))
                    break
            else:
                self.failed_attempts += 1

            if self.failed_attempts >= len(HANGMAN):
                print("\n-----You lost!")
                break

import random
if __name__ == '__main__':
    word_to_guess = random.choice(WORDS)
    hangman = Hangman(word_to_guess)
    hangman.play()

class Tank:

   def __init__(self, name):
        self.name = name
        self.ammo = 5
        self.armor = 40
        self.alive = True
       # name 값 받기 / alive, ammo, armor 의 인스턴스 변수를 설정한다.


   def __str__(self): # 인스턴스가 print 안에서 호출 될 때마다 상태 업데이트해줌.

       if self.alive : # 살아있는 경우
           return "%s (%i armor and %i shells left)" % (self.name, self.armor, self.ammo)
       else: # 죽은 경우
           return "%s is DEAD !" % self.name

   def fire_at(self, enemy): # 현재 인스턴스가 다른 인스턴스를 공격.

       if self.ammo != 0: # 쏠 수 있는 포탄이 남아있는 경우
           self.ammo -= 1  # 포탄 갯수가 감소
           print(self.name, " fires on ", enemy.name)
           enemy.hit()# 상대 탱크는 맞았기 때문에 맞았을 경우에 대한 메소드 실행.
       else:
           print(self.name, " has no shells!")

   def hit(self):

       self.armor -= 20 # 맞으면 기본 체력 20 감소
       print(self.name, " is hit !")
       if self.armor <= 0 : # 방어력이 없으면
           self.explode() # 폭발됨.

   def explode(self):
       self.alive = False
       print(self.name, " explodes !!!!")

tanks = {"a": Tank("Alice"), "b": Tank("Bob"), "c": Tank("Crane")}
alive_tanks = len(tanks)

while alive_tanks > 1 : # 살아남은 탱크가 하나보다 많은 동안.

    for tank_name in sorted(tanks):
        print(tank_name, tanks[tank_name])

    first = input("Who fires (select from a, b, c)?").lower()
    second = input("Who at (select from a, b, c) ?").lower()

    try : # 실행
        first_tank = tanks[first]
        second_tank = tanks[second] # 첫번째 두번째 탱크 할당.
    except KeyError as name : # KeyError 인 경우 에러를 name 에 담은 후. Exception as e
        print("No such Tank!", name) # 에러 메세지 출력.
        continue

    print("*"*30)

    first_tank.fire_at(second_tank) # 첫번째 탱크가 두번째 탱크를 공격
    if not second_tank.alive:
        alive_tanks -= 1

    print("*"*30)

for tank in tanks.values():
    if tank.alive: # 살아남은 탱크 하나에 대해 다음 출력함.
        print(tank.name, " is the winner !")
        break

